// Code generated by genapi. DO NOT EDIT.
package main

import (
	"encoding/json"
	"io"
	"net/http"
	"regexp"
	"strconv"
)

// Avoid unused import errors.
var _ = json.Marshal
var _ = regexp.MustCompile
var _ = http.MethodGet

var reGetUser = regexp.MustCompile(`^/users/(?P<id>[^/]+)[/]?$`)
var reGetAvatar = regexp.MustCompile(`^/users/(?P<id>[^/]+)/avatar[/]?$`)
var reCreateUser = regexp.MustCompile(`^/users[/]?$`)
var reListUsers = regexp.MustCompile(`^/users[/]?$`)
var reShutdown = regexp.MustCompile(`^/shutdown[/]?$`)

func (h *Service) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var err error
	var res any
	if matches := reGetUser.FindStringSubmatch(r.URL.Path); matches != nil && r.Method == "GET" {
		var param1 int
		param1, err = strconv.Atoi(matches[1])
		if err != nil {
			http.Error(w, "id: "+err.Error(), http.StatusBadRequest)
			return
		}
		res, err = h.GetUser(ID(param1))
	} else if matches := reGetAvatar.FindStringSubmatch(r.URL.Path); matches != nil && r.Method == "GET" {
		var param1 int
		param1, err = strconv.Atoi(matches[1])
		if err != nil {
			http.Error(w, "id: "+err.Error(), http.StatusBadRequest)
			return
		}
		res, err = h.GetAvatar(ID(param1))
	} else if matches := reCreateUser.FindStringSubmatch(r.URL.Path); matches != nil && r.Method == "POST" {
		var param0 User
		dec := json.NewDecoder(r.Body)
		dec.DisallowUnknownFields()
		if err := dec.Decode(&param0); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		err = h.CreateUser(param0)
	} else if matches := reListUsers.FindStringSubmatch(r.URL.Path); matches != nil && r.Method == "GET" {
		res, err = h.ListUsers()
	} else if matches := reShutdown.FindStringSubmatch(r.URL.Path); matches != nil && r.Method == "POST" {
		h.Shutdown(w)
		return
	} else {
		// We don't return a 404 here to allow the default handler to handle it.
		return
	}

	// Handle errors
	if err != nil {
		if herr, ok := err.(http.Handler); ok {
			herr.ServeHTTP(w, r)
		} else {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
		return
	}

	// Handle response
	switch res := res.(type) {
	case nil:
		w.WriteHeader(http.StatusNoContent)
	case string:
		w.Header().Set("Content-Type", "text/html")
		io.WriteString(w, res)
	case []byte:
		w.Header().Set("Content-Type", "application/octet-stream")
		w.Write(res)
	case *http.Response:
		headers := w.Header()
		for k, v := range res.Header {
			headers[k] = v
		}
		w.WriteHeader(res.StatusCode)
		_, _ = io.Copy(w, res.Body)
	case io.ReadCloser:
		w.Header().Set("Content-Type", "application/octet-stream")
		_, _ = io.Copy(w, res)
		res.Close()
	case io.Reader:
		w.Header().Set("Content-Type", "application/octet-stream")
		_, _ = io.Copy(w, res)
	default:
		data, err := json.Marshal(res)
		if err != nil {
			http.Error(w, `failed to encode response: `+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Content-Length", strconv.Itoa(len(data)))
		w.WriteHeader(http.StatusOK)
		w.Write(data)
	}
}
