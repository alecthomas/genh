package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"net/http"
	"os"
	"path"
	"regexp"
	"strings"

	"github.com/alecthomas/kong"
	"golang.org/x/tools/go/packages"
)

var (
	cli struct {
		Pkg string `arg:"" help:"Package to scan for API definitions. See https://github.com/alecthomas/genh for help." default:"."`
	}
	fset = token.NewFileSet()
	// httpHandlerInterface     = mustLoadInterface("net/http", "Handler")
	textUnmarshalerInterface = mustLoadInterface("encoding", "TextUnmarshaler")
)

type directive struct {
	method      string
	path        string
	pathParams  []string
	contentType string
}

type endpoint struct {
	decl      *ast.FuncDecl
	fn        *types.Func
	signature *types.Signature
	directive directive
}

func main() {
	kctx := kong.Parse(&cli, kong.Description(`
genh automatically generates http.RequestHandler boilerplate for routing to Go
methods annotated with comment directives. The generated code decodes the
incoming HTTP request into the method's parameters, and encodes method return
values to HTTP responses.
`), kong.HelpOptions{WrapUpperBound: 90})
	pkgs, err := packages.Load(&packages.Config{
		Fset: fset,
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo,
	}, cli.Pkg)
	kctx.FatalIfErrorf(err)

	didWork := false
	for _, pkg := range pkgs {
		outPath, endpoints, err := extractEndpoints(pkg)
		kctx.FatalIfErrorf(err)
		if len(endpoints) == 0 {
			continue
		}
		didWork = true
		imports := map[string]bool{
			"net/http":      true,
			"regexp":        true,
			"io":            true,
			"encoding/json": true,
			"strconv":       true,
		}

		body := &bytes.Buffer{}
		for _, eps := range endpoints {
			// Precompile all the regexes.
			extraImports, err := generateHandler(body, pkg, eps)
			kctx.FatalIfErrorf(err)
			for _, imp := range extraImports {
				imports[imp] = true
			}
		}

		header := &bytes.Buffer{}

		p := func(format string, args ...interface{}) {
			fmt.Fprintf(header, format, args...)
		}

		p("// Code generated by genapi. DO NOT EDIT.\n")
		p("package %s\n", pkg.Name)

		p("import (\n")
		for imp := range imports {
			p("  %q\n", imp)
		}
		p(")\n")
		p("\n")
		p("// Avoid unused import errors.\n")
		p("var _ = json.Marshal\n")
		p("var _ = regexp.MustCompile\n")
		p("var _ = http.MethodGet\n")
		p("\n")

		source := append(header.Bytes(), body.Bytes()...)
		formatted, err := format.Source(source)
		if err != nil {
			for i, line := range bytes.Split(source, []byte("\n")) {
				fmt.Printf("%3d: %s\n", i+1, line)
			}
			kctx.FatalIfErrorf(err)
		}
		err = os.WriteFile(outPath, formatted, 0600)
		kctx.FatalIfErrorf(err)
	}

	if !didWork {
		kctx.Fatalf("no annotated endpoints found, nothing to do")
	}
}

func generateHandler(w io.Writer, pkg *packages.Package, eps []endpoint) (imports []string, err error) {
	var ptr string
	var recvType *types.Named
	recv := eps[0].signature.Recv().Type()
	if ptrt, ok := recv.(*types.Pointer); ok {
		ptr = "*"
		recvType = ptrt.Elem().(*types.Named)
	}
	p := func(format string, args ...interface{}) {
		fmt.Fprintf(w, format, args...)
	}
	// Resolve a type to its import and local name.
	typeRef := func(t types.Type) (pkgRef, ref string) {
		if named, ok := t.(*types.Named); ok {
			pkgRef = named.Obj().Pkg().Path()
			ref = named.Obj().Name()
			if pkgRef == pkg.PkgPath {
				pkgRef = ""
			} else {
				ref = path.Base(pkgRef) + "." + ref
			}
			return
		}
		return "", t.String()
	}
	for _, ep := range eps {
		p("var re%s = regexp.MustCompile(`^%s$`)\n", ep.fn.Name(), ep.directive.path)
	}
	p("\n")
	p("func (h %s%s) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n", ptr, recvType.Obj().Name())
	p("  var err error\n")
	p("  var res any\n")
	for i, ep := range eps {
		if i > 0 {
			p(" else ")
		}
		re := regexp.MustCompile(ep.directive.path)
		p("  if matches := re%s.FindStringSubmatch(r.URL.Path); matches != nil && r.Method == %q {\n", ep.fn.Name(), ep.directive.method)
		params := ep.signature.Params()
		isParam := map[string]bool{}
		for i := 0; i < params.Len(); i++ {
			isParam[params.At(i).Name()] = true
		}
		isGroup := map[string]int{}
		for _, group := range re.SubexpNames()[1:] {
			isGroup[group] = re.SubexpIndex(group)
		}

		args := []string{}
		for i := 0; i < params.Len(); i++ {
			param := params.At(i)
			pos := pkg.Fset.Position(param.Pos())
			tn := param.Type().String()
			switch {
			case tn == "context.Context":
				args = append(args, "r.Context()")

			case tn == "net/http.ResponseWriter":
				args = append(args, "w")
				imports = append(imports, "net/http")

			case tn == "io.Reader":
				args = append(args, "r.Body")

			case tn == "*net/http.Request":
				args = append(args, "r")
				imports = append(imports, "net/http")

			case isGroup[param.Name()] != 0:
				index := isGroup[param.Name()]
				pkgRef, ref := typeRef(param.Type())
				if pkgRef != "" {
					imports = append(imports, pkgRef)
				}
				bt := param.Type().Underlying().String()
				// Type aliases (eg. type Foo int) are supported if they alias
				// string or int, or implement encoding.TextUnmarshaler.
				switch {
				case types.Implements(param.Type(), textUnmarshalerInterface):
					paramName := fmt.Sprintf("param%d", index)
					p("  var %s %s\n", paramName, ref)
					p("  err = %s.UnmarshalText([]byte(matches[%d]))\n", paramName, index)
					args = append(args, fmt.Sprintf("%s(%s)", ref, paramName))

				case bt == "string":
					if bt != ref {
						args = append(args, fmt.Sprintf("%s(matches[%d])", ref, index))
					} else {
						args = append(args, fmt.Sprintf("matches[%d]", index))
					}

				case bt == "int":
					paramName := fmt.Sprintf("param%d", index)
					p("  var %s int\n", paramName)
					p("  %s, err = strconv.Atoi(matches[%d])\n", paramName, index)
					if bt != ref {
						args = append(args, fmt.Sprintf("%s(%s)", ref, paramName))
					} else {
						args = append(args, paramName)
					}
					p("  if err != nil {\n")
					p("    http.Error(w, \"%s: \" + err.Error(), http.StatusBadRequest)\n", param.Name())
					p("    return\n")
					p("  }\n")

				default:
					return nil, fmt.Errorf("%s: %s: unsupported named parameter type %q", pos, param.Name(), param.Type())
				}

			// Not a parameter, so it must be a request body or query parameters.
			default: // TODO(aat): Handle pointers.
				_, ok := param.Type().(*types.Named)
				if !ok {
					return nil, fmt.Errorf("%s: parameter %q does not map to any URL path variables and is of type %q, which is not a usable request payload type", pos, param.Name(), param.Type())
				}
				pkgRef, ref := typeRef(param.Type())
				if pkgRef != "" {
					imports = append(imports, pkgRef)
				}

				imports = append(imports, "encoding/json")
				p("    var param%d %s\n", i, ref)
				if ep.directive.method == http.MethodGet || ep.directive.method == http.MethodDelete {
					p("    // Unmarshal query parameters through JSON\n")
					p("    query := map[string]string{}\n")
					p("    for k, v := range r.URL.Query() {\n")
					p("	     query[k] = v[len(v)-1]\n")
					p("     }\n")
					p("    data, _ := json.Marshal(query)\n")
					p("    dec := json.NewDecoder(bytes.NewReader(data))\n")
					p("    dec.DisallowUnknownFields()\n")
					p("    if err := dec.Decode(&param%d); err != nil {\n", i)
					p("      http.Error(w, \"Could not decode query parameters: \" + err.Error(), http.StatusBadRequest)\n")
					p("      return\n")
					p("    }\n")
					imports = append(imports, "bytes")
				} else {
					p("    dec := json.NewDecoder(r.Body)\n")
					p("    dec.DisallowUnknownFields()\n")
					p("    if err := dec.Decode(&param%d); err != nil {\n", i)
					p("      http.Error(w, err.Error(), http.StatusBadRequest)\n")
					p("      return\n")
					p("    }\n")
				}
				args = append(args, fmt.Sprintf("param%d", i))
			}
		}
		results := ep.signature.Results()
		switch results.Len() {
		case 0:
		case 2:
			p("  res, err = ")
			pos := pkg.Fset.Position(results.At(0).Pos())
			resType := results.At(0).Type()
			switch resType.String() {
			case "string", "[]byte", "*net/http.Response":
			default:
				switch resType.(type) {
				case *types.Named, *types.Slice, *types.Map:
				default:
					return nil, fmt.Errorf("%s: unsupported return type: %s", pos, results.At(0).Type())
				}
			}
		case 1:
			if results.At(0).Type().String() == "error" {
				p("  err = ")
				break
			}
			fallthrough
		default:
			return nil, fmt.Errorf("%s: handler return values must be in the form (error) or (T, error)", ep.fn.Name())
		}
		p("  h.%s(%s)\n", ep.fn.Name(), strings.Join(args, ", "))
		if results.Len() == 0 {
			p("  return\n")
		}
		p("}")
	}
	p(" else {\n")
	p("    // We don't return a 404 here to allow the default handler to handle it.\n")
	p("    return\n")
	p("  }\n")
	p("\n")
	p("  // Handle errors\n")
	p("  if err != nil {\n")
	p("    if herr, ok := err.(http.Handler); ok {\n")
	p("      herr.ServeHTTP(w, r)\n")
	p("    } else {\n")
	p("		 http.Error(w, err.Error(), http.StatusInternalServerError)\n")
	p("    }\n")
	p("    return\n")
	p("  }\n")
	p("\n")
	p("  // Handle response\n")
	p("  switch res := res.(type) {\n")
	p("  case nil:\n")
	p("    w.WriteHeader(http.StatusNoContent)\n")
	p("  case string:\n")
	p("    w.Header().Set(\"Content-Type\", \"text/html\")\n")
	p("    io.WriteString(w, res)\n")
	p("  case []byte:\n")
	p("    w.Header().Set(\"Content-Type\", \"application/octet-stream\")\n")
	p("    w.Write(res)\n")
	p("  case *http.Response:")
	p("    headers := w.Header()\n")
	p("    for k, v := range res.Header {\n")
	p("      headers[k] = v\n")
	p("    }\n")
	p("    w.WriteHeader(res.StatusCode)\n")
	p("    _, _ = io.Copy(w, res.Body)\n")
	p("  case io.ReadCloser:\n")
	p("    w.Header().Set(\"Content-Type\", \"application/octet-stream\")\n")
	p("    _, _ = io.Copy(w, res)\n")
	p("    res.Close()\n")
	p("  case io.Reader:\n")
	p("    w.Header().Set(\"Content-Type\", \"application/octet-stream\")\n")
	p("    _, _ = io.Copy(w, res)\n")
	p("  default:\n")
	p("    data, err := json.Marshal(res)\n")
	p("    if err != nil {\n")
	p("      http.Error(w, `failed to encode response: ` + err.Error(), http.StatusInternalServerError)\n")
	p("      return\n")
	p("    }\n")
	p("    w.Header().Set(\"Content-Type\", \"application/json\")\n")
	p(`	   w.Header().Set("Content-Length", strconv.Itoa(len(data)))` + "\n")
	p("    w.WriteHeader(http.StatusOK)\n")
	p("    w.Write(data)\n")
	p("  }\n")
	p("}\n")
	return imports, nil
}

//nolint:nakedret
func extractEndpoints(pkg *packages.Package) (outPath string, endpoints map[string][]endpoint, retErr error) {
	endpoints = map[string][]endpoint{}
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(node ast.Node) bool {
			fn, ok := node.(*ast.FuncDecl)
			if !ok || fn.Doc == nil {
				return true
			}
			for _, line := range fn.Doc.List {
				if strings.HasPrefix(line.Text, "//genh:api") {
					pos := pkg.Fset.Position(fn.Pos())
					dir, err := parseDirective(line.Text)
					if err != nil {
						retErr = fmt.Errorf("%s: %w", pos, err)
						return false
					}
					fnt := pkg.TypesInfo.Defs[fn.Name].(*types.Func)
					sig := fnt.Type().(*types.Signature)
					receiverName := sig.Recv().Type().String()
					endpoints[receiverName] = append(endpoints[receiverName], endpoint{
						decl:      fn,
						fn:        fnt,
						signature: sig,
						directive: dir,
					})
				}
			}
			return true
		})
		if retErr != nil {
			return
		}
		if outPath == "" && len(endpoints) > 0 {
			f := pkg.Fset.File(file.Pos())
			outPath = strings.TrimSuffix(f.Name(), ".go") + "_api.go"
		}
	}
	return
}

var nameExtract = regexp.MustCompile(`/:([a-zA-Z0-9]+)`)

// <method> <path> [mime-type=<mime-type>]
func parseDirective(comment string) (directive, error) {
	parts := strings.Fields(comment)
	if len(parts) < 3 {
		return directive{}, fmt.Errorf("invalid directive, must be in the form //api:http <method> <url> [<option>=<value>...]: %s", comment)
	}
	dir := directive{
		method: parts[1],
	}
	pattern := parts[2]
	matches := nameExtract.FindAllStringSubmatchIndex(pattern, -1)
	for _, parami := range matches {
		param := pattern[parami[2]:parami[3]]
		dir.pathParams = append(dir.pathParams, param)
	}
	path := ""
	if len(matches) != 0 {
		last := 0
		for _, parami := range matches {
			path += pattern[last : parami[0]+1]
			path += "(?P<" + pattern[parami[2]:parami[3]] + ">[^/]+)"
			last = parami[1]
		}
		path += pattern[matches[len(matches)-1][1]:]
	} else {
		path = pattern
	}
	path = strings.TrimSuffix(path, "/")
	path += "[/]?"
	dir.path = path

	if len(parts) > 3 {
		for _, option := range parts[3:] {
			parts := strings.SplitN(option, "=", 2)
			var value string
			if len(parts) == 2 {
				value = parts[1]
			}
			switch parts[0] {
			case "content-type":
				dir.contentType = value

			default:
				return directive{}, fmt.Errorf("unknown option %s", parts[0])
			}
		}
	}
	return dir, nil
}

func mustLoadInterface(pkg, name string) *types.Interface {
	pkgs, err := packages.Load(&packages.Config{Fset: fset, Mode: packages.NeedTypes}, pkg)
	if err != nil {
		panic(err)
	}
	if len(pkgs) != 1 {
		panic("expected one package")
	}
	iface := pkgs[0].Types.Scope().Lookup(name)
	if iface == nil {
		panic("interface not found")
	}
	return iface.Type().Underlying().(*types.Interface)
}
